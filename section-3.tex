%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modeling Part-Whole Complexes as Presheaves}
\label{sec:sheaf-mereology}

\noindent
As noted in \cref{sec:introduction}, the central claim of this paper is that we can model part-whole complexes as presheaves over locales, with varying gluing conditions. In particular, the locale provides the abstract parts space of ``regions'' that the pieces can occupy, the presheaf assigns actual pieces to those regions, and the gluings determine which pieces fuse.

We can thus define the core mereological concepts of part and whole in sheaf-theoretic terms. Regarding wholes, we can identify fusion with gluing: to say that some pieces fuse or form a ``fusion'' is just to say that they are glued together. Regarding parts, to say that a piece is a ``part'' is just to say that it is a part of a fusion. In other words, the parts of a fusion are just the pieces from which it is glued together.

\def\partOf/{\sqsubseteq}

\begin{Definition}[Fusions and parts]

We say that a section $s \in F(U)$ is a fusion iff there exists a cover $\{ U_{i} \}_{i \in I}$ of $U$ and a selection of patch candidates $\{ s_{i} \}_{i \in I}$ such that:

\[ 
\restrict{U}{U_{i}}(s) = s_{i}, \quad \text{ for each } U_{i}.
\]

\noindent
Given $t \in F(V)$ and $s \in F(U)$ with $V \childOf/ U$ and $V \not = \bottom/$, we say $t$ is a part of $s$, denoted $t \partOf/ s$, iff $s$ is a fusion and:

\[
\restrict{U}{V}(s) = t.
\]

\end{Definition}

Because fusions do not freely arise here, but rather only exist where parts are explicitly glued together, sheaf theory thus provides a systematic framework with which to model a large variety of part-whole complexes in a ``fusions-first'' manner. In the rest of this section, we illustrate with examples. In each case, we construct a custom presheaf designed to model a particular part-whole complex. Our choices of presheaves should be interpreted as modeling choices. One could construct different presheaves, and each can be evaluated on its own merits. 

% ----------------------------------------
\begin{Example}
\label{ex:wr-h-er}

Consider a building with a west room, an east room, and a hallway between them. For simplicity, let us consider only the floors of the building (ignore walls, ceilings, and so on). The ambient locale is given by the presentation

\begin{itemize}

\item $\category{L} = \tuple{G, R} = \tuple{\{ WR, H, ER \}, \EmptySet/}$

\end{itemize}

\noindent
where

\begin{itemize}

\item $WR$ = west room
\item $H$ = hallway
\item $ER$ = east room

\end{itemize}

\noindent
As a Hasse diagram:

\begin{diagram}

\node (WR_v_H_v_ER) at (0, 3) {$WR \join/ H \join/ ER$};
\node (WR_v_H) at (-2, 2) {$WR \join/ H$};
\node (WR_v_ER) at (0, 2) {$WR \join/ ER$};
\node (H_v_ER) at (2, 2) {$H \join/ ER$};
\node (WR) at (-2, 1) {$WR$};
\node (H) at (0, 1) {$H$};
\node (ER) at (2, 1) {$ER$};
\node (bottom) at (0, 0) {$\bottom/$};

\draw (bottom) to (WR);
\draw (bottom) to (H);
\draw (bottom) to (ER);
\draw (WR) to (WR_v_H);
\draw (WR) to (WR_v_ER);
\draw (H) to (WR_v_H);
\draw (H) to (H_v_ER);
\draw (ER) to (WR_v_ER);
\draw (ER) to (H_v_ER);
\draw (WR_v_H) to (WR_v_H_v_ER);
\draw (WR_v_ER) to (WR_v_H_v_ER);
\draw (H_v_ER) to (WR_v_H_v_ER);

\end{diagram}

\noindent
For the presheaf $F$, let it assign to each region whatever materials (if any) cover its floor uniformly. Let us say that the west room's and hallway's floors are each covered uniformly by wood, while the east room's floor is covered uniformly by tiles:

\begin{itemize}

\item $F(WR) = \{ wood \}$
\item $F(H) = \{ wood \}$
\item $F(ER) = \{ tile \}$

\end{itemize}

\noindent
Since the west room's and hallway's floors are covered uniformly by wood, their join is too:

\begin{itemize}

\item $F(WR \join/ H) = \{ wood \}$

\end{itemize}

\noindent
Since none of the other regions are covered uniformly by the same material, we assign nothing to them:

\begin{itemize}

\item $F(WR \join/ ER) = \EmptySet/$
\item $F(H \join/ ER) = \EmptySet/$
\item $F(WR \join/ H \join/ ER) = \EmptySet/$

\end{itemize}

\noindent
Finally, for the fiber over bottom, where there are no regions to cover with materials, let us assign the special symbol zero:

\begin{itemize}

\item $F(\bottom/) = \{ 0 \}$

\end{itemize}

\noindent
For the restrictions, let us say that the materials that cover a larger region are restricted down to the materials that cover the smaller region. Hence, the non-empty fibers restrict by identity:

\begin{itemize}

\item $\restrict{WR \join/ H}{WR}(wood) = \restrict{WR \join/ H}{H}(wood) = wood$

\end{itemize}

\noindent
The empty fibers restrict via the empty function (there is nothing to restrict):

\begin{itemize}

\item $\restrict{WR \join/ H \join/ ER}{WR \join/ H} = \restrict{WR \join/ H \join/ ER}{WR \join/ ER} = \restrict{WR \join/ H \join/ ER}{H \join/ ER} = \text{ empty function }$
\item $\restrict{WR \join/ ER}{WR} = \restrict{WR \join/ ER}{ER} = \text{ empty function }$
\item $\restrict{H \join/ ER}{H} = \restrict{H \join/ ER}{ER} = \text{ empty function }$

\end{itemize}

\noindent
Finally, fibers restrict to bottom via the constant function: 

\begin{itemize}

\item $\restrict{WR}{\bottom/}(wood) = \restrict{H}{\bottom/}(wood) = \restrict{ER}{\bottom/}(tile) = 0$

\end{itemize}

\noindent
In this building, there are two maximal fusions:

\begin{itemize}

\item The flooring of the west room and the hallway glue into one piece that covers both.
\item The flooring that covers the east room.

\end{itemize}

\noindent
Thus, the flooring of this building is really a collection of two independent fusions: the wooden floor that covers the west room and hallway, and the tiled floor that covers the east room. That implies: 

\begin{itemize}

\item To separate the floors of the west room and hallway, you would have to use a saw to cut them, since they are fused. They are not merely sitting next to each other. Rather, they make up a single (fused) piece.

\item By contrast, to separate the hallway and the east room, you would not need to cut them, since they are not fused. They simply happen to be sitting next to each other.

\end{itemize}

\noindent
The parts of the fusions are clear:

\begin{itemize}

\item The wooden floor that covers the west room and the hallway has two parts: the wooden floor that covers the west room, and the wooden floor that covers the hallway.

\item The tiled floor of the east room has no parts (in this locale), since it is not the fusion of other fusions.

\end{itemize}

\noindent
This is particular example fails to be a sheaf, because everything that can glue does not glue. In particular, $F(WR \join/ H \join/ ER)$ is covered by $\{ WR, H, ER \}$, and the patch candidates $\{ wood, wood, tile \}$ are compatible (they pair-wise restrict to $0$). However, there is nothing in $F(WR \join/ H \join/ ER)$ that is glued together from those patch candidates (indeed, $F(WR \join/ H \join/ ER)$ is empty). Hence, this is not a sheaf. Rather, it is a monopresheaf.

But this is precisely what one would expect when modeling two discrete pieces of flooring that happen to sit next to each other. The west room and hallway do glue together here, as expected. But the maximal wood and tile pieces do not glue together, also as expected (there is a boundary between them, where the wood ends and the tile begins). 

\end{Example}

In the previous example, none of the regions overlapped. The presheaf was free to glue or not glue pieces as it saw fit. The story is different if there are overlaps in the locale itself. Overlaps in the locale require overlaps in the presheaf, wherever you want gluings.

% ----------------------------------------
\begin{Example}
\label{ex:wh-o-eh}

Consider the floor of a single room. Let us say that the regions of interest are its west half, its east half, and a six inch span where they overlap.

The ambient locale of this kind of space can be given by the presentation

\begin{itemize}

\item $L = \tuple{G, R} = 
  \tuple{\{ \bottom/, WH, O, EH \}, \{\bottom/ \childOf/ O, O \childOf/ WH, O \childOf/ EH\}}$

\end{itemize}

\noindent
where

\begin{itemize}

\item $WH$ = west half
\item $O$ = overlap
\item $EH$ = east half

\end{itemize}

\noindent
For a presheaf $F$, let us say that it behaves much like in the previous example: it assigns to each region the materials (if any) that cover the floor uniformly. 

For instance, let us assign wood to both halves:

\begin{itemize}

\item $F(WH) = \{ wood \}$
\item $F(EH) = \{ wood \}$

\end{itemize}

\noindent
In a picture:

\begin{diagram}

\node (WH_v_EH) at (0, 3) {$WH \join/ EH$};
\node (WH) at (-2, 1.5) {$WH$};
\node (EH) at (2, 1.5) {$EH$};
\node (O) at (0, 0) {$O$};
\node (bottom) at (0, -1.5) {$\bottom/$};

\draw[dashed] (O) to (bottom);
\draw[dashed] (O) to (WH);
\draw[dashed] (O) to (EH);
\draw[dashed] (WH) to (WH_v_EH);
\draw[dashed] (EH) to (WH_v_EH);

\draw (-2, 1.75) to (-2, 2.275);
\draw (-2.55, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=left:{\small{$wood$}}] (wood_WH) at (-2, 2.75) {};

\draw (2, 1.75) to (2, 2.275);
\draw (2.5, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=right:{\small{$wood$}}] (wood_EH) at (2, 2.75) {};

\end{diagram}

\noindent
By construction $O = WH \meet/ EH$, and the two halves restrict to the same material there:

\begin{itemize}

\item $F(O) = \{ wood \}$
    
\end{itemize}

\noindent
Thus:

\begin{diagram}

\node (WH_v_EH) at (0, 3) {$WH \join/ EH$};
\node (WH) at (-2, 1.5) {$WH$};
\node (EH) at (2, 1.5) {$EH$};
\node (O) at (0, 0) {$O$};
\node (bottom) at (0, -1.5) {$\bottom/$};

\draw[dashed] (O) to (bottom);
\draw[dashed] (O) to (WH);
\draw[dashed] (O) to (EH);
\draw[dashed] (WH) to (WH_v_EH);
\draw[dashed] (EH) to (WH_v_EH);

\draw (-2, 1.75) to (-2, 2.275);
\draw (-2.55, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=left:{\small{$wood$}}] (wood_WH) at (-2, 2.75) {};

\draw (2, 1.75) to (2, 2.275);
\draw (2.5, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=right:{\small{$wood$}}] (wood_EH) at (2, 2.75) {};

\draw (0, 0.25) to (0, 0.5);
\draw (0, 1.5) ellipse (0.85cm and 0.75cm);
\node[dot, label=below:{\small{$wood$}}] (wood_O) at (0, 1.5) {};

\draw[arrow, ->] (wood_WH) to (wood_O);
\draw[arrow, ->] (wood_EH) to (wood_O);

\end{diagram}

\noindent
For the join, the west and east halves glue, since they're made from the same flooring materials and agree on their overlap:

\begin{itemize}

\item $F(WH \join/ EH) = \{ wood \}$

\end{itemize}

\noindent
Thus:

\begin{diagram}

\node (WH_v_EH) at (0, 3) {$WH \join/ EH$};
\node (WH) at (-2, 1.5) {$WH$};
\node (EH) at (2, 1.5) {$EH$};
\node (O) at (0, 0) {$O$};
\node (bottom) at (0, -1.5) {$\bottom/$};

\draw[dashed] (O) to (bottom);
\draw[dashed] (O) to (WH);
\draw[dashed] (O) to (EH);
\draw[dashed] (WH) to (WH_v_EH);
\draw[dashed] (EH) to (WH_v_EH);

\draw (-2, 1.75) to (-2, 2.275);
\draw (-2.55, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=left:{\small{$wood$}}] (wood_WH) at (-2, 2.75) {};

\draw (2, 1.75) to (2, 2.275);
\draw (2.5, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=right:{\small{$wood$}}] (wood_EH) at (2, 2.75) {};

\draw (0, 0.25) to (0, 0.5);
\draw (0, 1.5) ellipse (0.85cm and 0.75cm);
\node[dot, label=below:{\small{$wood$}}] (wood_O) at (0, 1.5) {};

\draw (0, 3.25) to (0, 3.75);
\draw (0, 4.25) ellipse (0.75cm and 0.75cm);
\node[dot, label=above:{\small{$wood$}}] (wood_WH_v_EH) at (0, 4) {};

\draw[arrow, ->] (wood_WH_v_EH) to (wood_WH);
\draw[arrow, ->] (wood_WH_v_EH) to (wood_EH);
\draw[arrow, ->] (wood_WH) to (wood_O);
\draw[arrow, ->] (wood_EH) to (wood_O);

\end{diagram}

\noindent
Finally, for the fiber over bottom, where there are no regions to cover with materials, assign the special symbol zero:

\begin{itemize}

\item $F(\bottom/) = \{ 0 \}$

\end{itemize}

\noindent
In a picture:


\begin{diagram}

\node (WH_v_EH) at (0, 3) {$WH \join/ EH$};
\node (WH) at (-2, 1.5) {$WH$};
\node (EH) at (2, 1.5) {$EH$};
\node (O) at (0, 0) {$O$};
\node (bottom) at (0, -1.5) {$\bottom/$};

\draw[dashed] (O) to (bottom);
\draw[dashed] (O) to (WH);
\draw[dashed] (O) to (EH);
\draw[dashed] (WH) to (WH_v_EH);
\draw[dashed] (EH) to (WH_v_EH);

\draw (-2, 1.75) to (-2, 2.275);
\draw (-2.55, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=left:{\small{$wood$}}] (wood_WH) at (-2, 2.75) {};

\draw (2, 1.75) to (2, 2.275);
\draw (2.5, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=right:{\small{$wood$}}] (wood_EH) at (2, 2.75) {};

\draw (0, 0.25) to (0, 0.5);
\draw (0, 1.5) ellipse (0.85cm and 0.75cm);
\node[dot, label=below:{\small{$wood$}}] (wood_O) at (0, 1.5) {};

\draw (0, 3.25) to (0, 3.75);
\draw (0, 4.25) ellipse (0.75cm and 0.75cm);
\node[dot, label=above:{\small{$wood$}}] (wood_WH_v_EH) at (0, 4) {};

\draw[arrow, ->] (wood_WH_v_EH) to (wood_WH);
\draw[arrow, ->] (wood_WH_v_EH) to (wood_EH);
\draw[arrow, ->] (wood_WH) to (wood_O);
\draw[arrow, ->] (wood_EH) to (wood_O);

\draw (0.25, -1.5) to (0.65, -1.1);
\draw (0.75, -0.65) ellipse (0.35cm and 0.5cm);
\node[dot, label=below:{\small{$0$}}] (0) at (0.75, -0.575) {};

\draw[arrow, ->] (wood_O) to[out=350, in=85] (0);

\end{diagram}

\noindent
The maximal fusion here is a single piece of wooden flooring (namely, $wood \in F(WH \join/ EH)$) that covers the whole room. Its parts are the west and east halves, and (transitively) their overlap. The west and east halves themselves have a shared part, the strip of overlap.

This particular example is a sheaf: the parts glue together coherently in a single manner across the entire parts space. This is exactly as one would expect when modeling a floor that is covered uniformly in its entirety by wood flooring: as you restrict down to smaller parts of the room, you get smaller pieces of wood flooring. In contrast to \cref{ex:wr-h-er}, here the regions have a nontrivial overlap. By the sheaf condition, agreement on that overlap forces a unique fusion of the parts, just as expected.

\end{Example}


% ----------------------------------------
\begin{Example}
\label{ex:wh-o-eh-fail}

To illustrate a failed attempt to build a sheaf, let us take the locale and gluing condition from \cref{ex:wh-o-eh}, but suppose that we assign different flooring materials to the east and west halves of the room:

\begin{itemize}

\item $F(WH) = \{ wood \}$
\item $F(EH) = \{ tile \}$

\end{itemize}

\noindent
As a picture:

\begin{diagram}

\node (WH_v_EH) at (0, 3) {$WH \join/ EH$};
\node (WH) at (-2, 1.5) {$WH$};
\node (EH) at (2, 1.5) {$EH$};
\node (O) at (0, 0) {$O$};
\node (bottom) at (0, -1.5) {$\bottom/$};

\draw[dashed] (O) to (bottom);
\draw[dashed] (O) to (WH);
\draw[dashed] (O) to (EH);
\draw[dashed] (WH) to (WH_v_EH);
\draw[dashed] (EH) to (WH_v_EH);

\draw (-2, 1.75) to (-2, 2.275);
\draw (-2.55, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=left:{\small{$wood$}}] (wood_WH) at (-2, 2.75) {};

\draw (2, 1.75) to (2, 2.275);
\draw (2.5, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=right:{\small{$tile$}}] (tile_EH) at (2, 2.75) {};

\end{diagram}

Next, at the overlap, allow both $wood$ and $tile$:

\begin{itemize}

\item $F(O) = \{ wood, tile \}$
\item $\restrict{WH}{O}(wood) = wood$
\item $\restrict{EH}{O}(tile) = tile$

\end{itemize}

\noindent
Thus, as a picture:

\begin{diagram}

\node (WH_v_EH) at (0, 3) {$WH \join/ EH$};
\node (WH) at (-2, 1.5) {$WH$};
\node (EH) at (2, 1.5) {$EH$};
\node (O) at (0, 0) {$O$};

\draw[dashed] (O) to (WH);
\draw[dashed] (O) to (EH);
\draw[dashed] (WH) to (WH_v_EH);
\draw[dashed] (EH) to (WH_v_EH);

\draw (-2, 1.75) to (-2, 2.275);
\draw (-2.55, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=left:{\small{$wood$}}] (wood_WH) at (-2, 2.75) {};

\draw (2, 1.75) to (2, 2.275);
\draw (2.5, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=right:{\small{$tile$}}] (tile_EH) at (2, 2.75) {};

\draw (0, 0.25) to (0, 0.5);
\draw (0, 1.5) ellipse (1cm and 1cm);
\node[dot, label=below:{\small{$wood$}}] (wood_O) at (0, 1.25) {};
\node[dot, label=below:{\small{$tile$}}] (tile_O) at (0, 2.1) {};

\draw[arrow, ->] (wood_WH) to (wood_O);
\draw[arrow, ->] (tile_EH) to (tile_O);

\end{diagram}

Note, however, that the wood and tile in the west and east halves cannot glue, because they do not agree on their overlap. Hence, there cannot be a single kind of flooring material that uniformly covers the maximal join $WH \join/ EH$. This illustrates how the sheaf condition is a very strong condition, but also a helpful one: it requires and manages coherent gluing at all levels. Because it requires that pieces glue together coherently at every level of ``zoom,'' it prevents us from ever putting together an incoherent part-whole sheaf in the first place.

It is worth spelling the failure out explicitly. If we want to model this room as a sheaf, then we are requiring coherent, unique gluing across all of the regions: wherever pieces can coherently glue together, they must do so. But here, since $WH$ and $EH$ disagree on their overlap, there is no way to make them cohere into a single piece.

Intuitively, this makes sense. If the western and eastern halves of a room were truly floored with different materials, then they could not overlap. Imagine if two builders started at opposite ends of the room: one flooring with wood and the other flooring with tile. When they reach the mid-point, they'd realize they made a mistake. In such a scenario, it would be impossible to complete the original vision of having a single, uniform flooring across the entire room.

However, what if we weaken our requirements and consider this as a presheaf? In a presheaf, nothing disallows the two halves from restricting differently on an overlap. The full presheaf looks like this:

\begin{diagram}

\node (WH_v_EH) at (0, 3) {$WH \join/ EH$};
\node (WH) at (-2, 1.5) {$WH$};
\node (EH) at (2, 1.5) {$EH$};
\node (O) at (0, 0) {$O$};
\node (bottom) at (0, -1.5) {$\bottom/$};

\draw[dashed] (O) to (bottom);
\draw[dashed] (O) to (WH);
\draw[dashed] (O) to (EH);
\draw[dashed] (WH) to (WH_v_EH);
\draw[dashed] (EH) to (WH_v_EH);

\draw (0, 3.25) to (0, 3.75);
\draw (0, 4.25) ellipse (0.75cm and 0.75cm);

\draw (-2, 1.75) to (-2, 2.275);
\draw (-2.55, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=left:{\small{$wood$}}] (wood_WH) at (-2, 2.75) {};

\draw (2, 1.75) to (2, 2.275);
\draw (2.5, 2.75) ellipse (1cm and 0.75cm);
\node[dot, label=right:{\small{$tile$}}] (tile_EH) at (2, 2.75) {};

\draw (0, 0.25) to (0, 0.5);
\draw (0, 1.5) ellipse (1cm and 1cm);
\node[dot, label=below:{\small{$wood$}}] (wood_O) at (0, 1.25) {};
\node[dot, label=below:{\small{$tile$}}] (tile_O) at (0, 2.1) {};

\draw[arrow, ->] (wood_WH) to (wood_O);
\draw[arrow, ->] (tile_EH) to (tile_O);

\draw (0.25, -1.5) to (0.65, -1.1);
\draw (0.75, -0.65) ellipse (0.35cm and 0.5cm);
\node[dot, label=below:{\small{$0$}}] (0) at (0.75, -0.575) {};

\draw[arrow, ->] (wood_O) to[out=350, in=85] (0);

\end{diagram}

\noindent
Interpreted as a presheaf, there is a sensible interpretation of this structure. Nothing sits in the fiber over $WH \join/ EH$, since a single coherent piece of flooring cannot be glued from wood and tile. The wood and tile from the two halves each extend into the overlap though, but since they don't agree, one of them must sit on top of the other in that overlapping area. It is like when two area rugs overlap: one sits on top of the other.

As a final point, note that this fails to be monopresheaf, because there are two sections in $F(O)$ that restrict to $\bottom/$. The gluings are trivial here, but nonetheless, gluing is not unique precisely in the overlap. Hence, this is a presheaf, but not a monopresheaf. This illustrates how presheaves allow multiple assemblies of parts, but monopresheaves do not.

\end{Example}

The previous two examples were spatial. But parts come in non-spatial guises too, and sheaf theory can model them just as well.

% ----------------------------------------
\begin{Example}
\label{ex:human-society}

Suppose we say that human society (under some description) consists of the mesh of a specified set of relationships between the people that participate in that society.

Let $P$ be the population in question (a finite set of individual people), and let the regions of our locale be subsets of such individuals. Then the ambient locale is given by the presentation:

\begin{itemize}

\item $\category{L} = \tuple{G, R} = \tuple{P, \EmptySet/}$

\end{itemize}

\noindent
For concreteness, suppose:

\begin{itemize}

\item $P = \{ A, B, C, D \}$, with $A$ short for Alice, $B$ for Bob, $C$ for Carol, and $D$ for Denny.

\end{itemize}

\noindent
Then the Hasse diagram is isomorphic to the powerset of $P$:

\begin{diagram}

\node (ABCD) at (0, 6) {$A \join/ B \join/ C \join/ D$};
\node (ABC) at (-3, 4.5) {$A \join/ B \join/ C$};
\node (ABD) at (-1, 4.5) {$A \join/ B \join/ D$};
\node (ACD) at (1, 4.5) {$A \join/ C \join/ D$};
\node (BCD) at (3, 4.5) {$B \join/ C \join/ D$};
\node (AB) at (-5, 3) {$A \join/ B$};
\node (AC) at (-3, 3) {$A \join/ C$};
\node (AD) at (-1, 3) {$A \join/ D$};
\node (BC) at (1, 3) {$B \join/ C$};
\node (BD) at (3, 3) {$B \join/ D$};
\node (CD) at (5, 3) {$C \join/ D$};
\node (A) at (-3, 1.5) {$A$};
\node (B) at (-1, 1.5) {$B$};
\node (C) at (1, 1.5) {$C$};
\node (D) at (3, 1.5) {$D$}; 
\node (bottom) at (0, 0) {$\bottom/$};

\draw (bottom) to (A);
\draw (bottom) to (B);
\draw (bottom) to (C);
\draw (bottom) to (D);
\draw (A) to (AB);
\draw (A) to (AC);
\draw (A) to (AD);
\draw (B) to (AB);
\draw (B) to (BC);
\draw (B) to (BD);
\draw (C) to (AC);
\draw (C) to (BC);
\draw (C) to (CD);
\draw (D) to (AD);
\draw (D) to (BD);
\draw (D) to (CD);
\draw (AB) to (ABC);
\draw (AB) to (ABD);
\draw (AC) to (ABC);
\draw (AC) to (ACD);
\draw (AD) to (ABD);
\draw (AD) to (ACD);
\draw (BC) to (ABC);
\draw (BC) to (BCD);
\draw (BD) to (ABD);
\draw (BD) to (BCD);
\draw (CD) to (ACD);
\draw (CD) to (BCD);
\draw (ABC) to (ABCD);
\draw (ABD) to (ABCD);
\draw (ACD) to (ABCD);
\draw (BCD) to (ABCD);

\end{diagram}

\noindent
Let us next define a presheaf $F$ that models the mesh of a selected set of relationships over $P$. To do that, let us first specify a set $R$ that picks out the (binary, symmetric) relationships of interest:

\begin{itemize}

\item $R = \{ f, m, \ldots \}$, with $f$ short for being friends, $m$ for being married, etc.

\end{itemize}

\noindent
For convenience, if $U, V \in P$, $r \in R$, and $U$ and $V$ stand in relationship $r$, we
will write $r(U, V)$.

For the generators, let us fix a choice of local data by assigning to each person the relations they stand in, e.g.:

\begin{itemize}

\item $F(A) = \{\tuple{\{ f(A, B), f(A, C), m(A, B) \}} \}$
\item $F(B) = \{\tuple{\{ f(B, A), m(B, A), f(B, D) \}} \}$
\item $F(C) = \{\tuple{\{ f(C, A), m(C, D) \}} \}$
\item $F(D) = \{\tuple{\{ f(D, B), m(D, C) \}} \}$

\end{itemize}

\noindent
To visualize this data, we can picture each fiber as a mini-graph:

\begin{diagram}

\node[dot] (Cf_over_A) at (-4.25, 3.25) [label=right:{\small{$C$}}] {};
\node[dot] (Bm_over_A) at (-5, 3.75) [label=above:{\small{$B$}}] {};
\node[dot] (Bf_over_A) at (-5.75, 3.25) [label=left:{\small{$B$}}] {};
\node[dot] (anchor_over_A) at (-5, 3) [label=below:{\small{$A$}}] {};
\node (A) at (-5, 1.5) {$A$};
\draw (A) to (-5, 2.25);
\draw (anchor_over_A) to node[midway, below left] {\small{$f$}} (Bf_over_A);
\draw (anchor_over_A) to node[midway, left] {\small{$m$}} (Bm_over_A);
\draw (anchor_over_A) to node[midway, below right] {\small{$f$}} (Cf_over_A);

\node[dot] (Df_over_B) at (-1.25, 3.25) [label=right:{\small{$D$}}] {};
\node[dot] (Am_over_B) at (-2, 3.75) [label=above:{\small{$A$}}] {};
\node[dot] (Af_over_B) at (-2.75, 3.25) [label=left:{\small{$A$}}] {};
\node[dot] (anchor_over_B) at (-2, 3) [label=below:{\small{$B$}}] {};
\node (B) at (-2, 1.5) {$B$};
\draw (B) to (-2, 2.25);
\draw (anchor_over_B) to node[midway, below left] {\small{$f$}} (Af_over_B);
\draw (anchor_over_B) to node[midway, left] {\small{$m$}} (Am_over_B);
\draw (anchor_over_B) to node[midway, below right] {\small{$f$}} (Df_over_B);

\node[dot] (Af_over_C) at (0.5, 3.5) [label=left:{\small{$A$}}] {};
\node[dot] (Dm_over_C) at (1.5, 3.5) [label=right:{\small{$D$}}] {};
\node[dot] (anchor_over_C) at (1, 3) [label=below:{\small{$C$}}] {};
\node (C) at (1, 1.5) {$C$};
\draw (C) to (1, 2.25);
\draw (anchor_over_C) to node[midway, below left] {\small{$f$}} (Af_over_C);
\draw (anchor_over_C) to node[midway, below right] {\small{$m$}} (Dm_over_C);

\node[dot] (Bf_over_D) at (3.5, 3.5) [label=left:{\small{$B$}}] {};
\node[dot] (Cm_over_D) at (4.5, 3.5) [label=right:{\small{$C$}}] {};
\node[dot] (anchor_over_D) at (4, 3) [label=below:{\small{$D$}}] {};
\node (D) at (4, 1.5) {$D$};
\draw (D) to (4, 2.25);
\draw (anchor_over_D) to node[midway, below left] {\small{$f$}} (Bf_over_D);
\draw (anchor_over_D) to node[midway, below right] {\small{$m$}} (Cm_over_D);

\end{diagram}

\noindent
For example, in the fiber over $A$:

\begin{itemize}

\item The $f$-labeled edge from $A$ to $B$ represents $f(A, B)$: $A$ and $B$ are friends.
\item The $m$-labeled edge from $A$ to $B$ represents $m(A, B)$: $A$ and $B$ are married.
\item The $f$-labeled edge from $A$ to $C$ represents $f(A, C)$: $A$ and $C$ are friends.

\end{itemize}

\noindent
In the bottom fiber, over the region of no people to carry relationships, assign the special symbol $0$:

\begin{itemize}

\item $F(\bottom/) = \{ 0 \}$

\end{itemize}

\noindent
Next, let us extend the above data to binary joins by merging mini-graphs along shared edges, wherever the components share exactly the same edges. To see how this works, consider (for example) the mini-graphs over $A$ and $C$:

\begin{diagram}

\node[dot] (Cf_over_A) at (-1.25, 3.25) [label=right:{\small{$C$}}] {};
\node[dot] (Bm_over_A) at (-2, 3.75) [label=above:{\small{$B$}}] {};
\node[dot] (Bf_over_A) at (-2.75, 3.25) [label=left:{\small{$B$}}] {};
\node[dot] (anchor_over_A) at (-2, 3) [label=below:{\small{$A$}}] {};
\draw (anchor_over_A) to node[midway, below left] {\small{$f$}} (Bf_over_A);
\draw (anchor_over_A) to node[midway, left] {\small{$m$}} (Bm_over_A);
\draw (anchor_over_A) to node[midway, below right] {\small{$f$}} (Cf_over_A);

\node[dot] (Af_over_C) at (1.5, 3.5) [label=left:{\small{$A$}}] {};
\node[dot] (Dm_over_C) at (2.5, 3.5) [label=right:{\small{$D$}}] {};
\node[dot] (anchor_over_C) at (2, 3) [label=below:{\small{$C$}}] {};
\draw (anchor_over_C) to node[midway, below left] {\small{$f$}} (Af_over_C);
\draw (anchor_over_C) to node[midway, below right] {\small{$m$}} (Dm_over_C);

\end{diagram}

\noindent
Can these be merged? The answer is yes, because they share exactly one edge, namely the one labeled $f$. If you rotate the graphs sideways a bit, you can see how they can be merged along $f(A, C)$:

\begin{diagram}

\node[dot] (Cf_over_A) at (-1.15, 3) [label=below right:{\small{$C$}}] {};
\node[dot] (Bm_over_A) at (-1.65, 3.75) [label=above:{\small{$B$}}] {};
\node[dot] (Bf_over_A) at (-2.5, 3.5) [label=left:{\small{$B$}}] {};
\node[dot] (anchor_over_A) at (-2, 3) [label=below left:{\small{$A$}}] {};
\draw (anchor_over_A) to node[midway, below left] {\small{$f$}} (Bf_over_A);
\draw (anchor_over_A) to node[midway, above left] {\small{$m$}} (Bm_over_A);
\draw (anchor_over_A) to node[midway, below] {\small{$f$}} (Cf_over_A);

\node[dot] (Af_over_C) at (1.15, 3) [label=below left:{\small{$A$}}] {};
\node[dot] (Dm_over_C) at (2, 3.75) [label=right:{\small{$D$}}] {};
\node[dot] (anchor_over_C) at (2, 3) [label=below right:{\small{$C$}}] {};
\draw (anchor_over_C) to node[midway, below] {\small{$f$}} (Af_over_C);
\draw (anchor_over_C) to node[midway, right] {\small{$m$}} (Dm_over_C);

\draw[dashed] (-2, 2.5) -- (-2, 2.35) -- (-1.15, 2.35) -- (-1.14, 2.5);
\draw[dashed] (1.15, 2.5) -- (1.15, 2.35) -- (2, 2.35) -- (2, 2.5);
\draw[dashed] (-1.65, 2.35) -- (-1.65, 2) -- (1.65, 2) -- (1.65, 2.35);
\node at (0, 1.75) {\small{merge these edges}};

\end{diagram}
 
\noindent
Merging along $f(A, C)$ yields the following graph:

\begin{diagram}

\node[dot] (Cf_over_A) at (-1.15, 3) [label=below right:{\small{$C$}}] {};
\node[dot] (Bm_over_A) at (-2, 3.75) [label=above:{\small{$B$}}] {};
\node[dot] (Bf_over_A) at (-2.75, 3.25) [label=left:{\small{$B$}}] {};
\node[dot] (anchor_over_A) at (-2, 3) [label=below left:{\small{$A$}}] {};
\node[dot] (Dm_over_Cf) at (-0.75, 3.75) [label=right:{\small{$D$}}] {};
\draw (anchor_over_A) to node[midway, below left] {\small{$f$}} (Bf_over_A);
\draw (anchor_over_A) to node[midway, left] {\small{$m$}} (Bm_over_A);
\draw (anchor_over_A) to node[midway, below] {\small{$f$}} (Cf_over_A);
\draw (Cf_over_A) to node[midway, below right] {\small{$m$}} (Dm_over_Cf);

\end{diagram}

\noindent
By merging all binary joins in this fashion, we get:

\begin{itemize}

\item $F(A \join/ B) = \{\tuple{\{ f(A, B), m(A, B), f(A, C) \}, \{ f(B, A), m(B, A), f(B, D) \}} \}$
\item $F(A \join/ C) = \{\tuple{\{ f(B, A), m(B, A), f(B, D) \}}, \{ f(C, A), m(C, D) \} \}$
\item $F(A \join/ D) = \EmptySet/$
\item $F(B \join/ C) = \EmptySet/$
\item $F(B \join/ D) = \{\tuple{\{ f(B, A), m(B, A), f(B, D) \}, \{ f(D, B), m(D, C) \}} \}$
\item $F(C \join/ D) = \{\tuple{\{ f(C, A), m(C, D) \}, \{ f(D, B), m(D, C) \}} \}$

\end{itemize}

\noindent
As pictures:

\begin{diagram}

\node[dot] (A_over_A_v_B) at (-4.4, 1.5) [label=below left:{\small{$A$}}] {};
\node[dot] (B_over_A_v_B) at (-3.6, 1.5) [label=below right:{\small{$B$}}] {};
\node[dot] (Cf_over_A_v_B) at (-4.6, 2.1) [label=above:{\small{$C$}}] {};
\node[dot] (Df_over_A_v_B) at (-3.4, 2.1) [label=above:{\small{$D$}}] {};
\node (A_v_B) at (-4, 0) {$A \join/ B$};
\draw (A_v_B) to (-4, 0.75);
\draw (A_over_A_v_B) to node[midway, left] {\small{$f$}} (Cf_over_A_v_B);
\draw (B_over_A_v_B) to node[midway, right] {\small{$f$}} (Df_over_A_v_B);
\draw (A_over_A_v_B) to[out=30, in=150] node[midway, above] {\small{$f$}} (B_over_A_v_B);
\draw (A_over_A_v_B) to[out=330, in=210] node[midway, below] {\small{$m$}} (B_over_A_v_B);

\node[dot] (A_over_A_v_C) at (-1.4, 1.5) [label=below left:{\small{$A$}}] {};
\node[dot] (C_over_A_v_C) at (-0.6, 1.5) [label=below right:{\small{$C$}}] {};
\node[dot] (Bm_over_A_v_C) at (-1.4, 2.2) [label=above:{\small{$B$}}] {};
\node[dot] (Bf_over_A_v_C) at (-2.1, 1.7) [label=left:{\small{$B$}}] {};
\node[dot] (Dm_over_A_v_C) at (-0.4, 2.2) [label=right:{\small{$D$}}] {};
\node (A_v_C) at (-1, 0) {$A \join/ C$};
\draw (A_v_C) to (-1, 0.75);
\draw (A_over_A_v_C) to node[midway, below left] {\small{$f$}} (Bf_over_A_v_C);
\draw (A_over_A_v_C) to node[midway, left] {\small{$m$}} (Bm_over_A_v_C);
\draw (A_over_A_v_C) to node[midway, below] {\small{$f$}} (C_over_A_v_C);
\draw (C_over_A_v_C) to node[midway, below right] {\small{$m$}} (Dm_over_A_v_C);

\node (empty_over_A_v_D_and_B_v_C) at (1, 1.25) {$\EmptySet/$};
\node (A_v_D_and_B_v_C) at (1, 0) {$A \join/ D$/$B \join/ C$};
\draw (A_v_D_and_B_v_C) to (1, 0.75);

\node[dot] (B_over_B_v_D) at (3.1, 1.5) [label=below left:{\small{$B$}}] {};
\node[dot] (D_over_B_v_D) at (3.9, 1.5) [label=below right:{\small{$D$}}] {};
\node[dot] (Am_over_B_v_D) at (3.1, 2.2) [label=above:{\small{$A$}}] {};
\node[dot] (Af_over_B_v_D) at (2.4, 1.7) [label=left:{\small{$A$}}] {};
\node[dot] (Cm_over_B_v_D) at (4.1, 2.2) [label=right:{\small{$C$}}] {};
\node (B_v_D) at (3.5, 0) {$B \join/ D$};
\draw (B_v_D) to (3.5, 0.75);
\draw (B_over_B_v_D) to node[midway, below left] {\small{$f$}} (Af_over_B_v_D);
\draw (B_over_B_v_D) to node[midway, left] {\small{$m$}} (Am_over_B_v_D);
\draw (B_over_B_v_D) to node[midway, below] {\small{$f$}} (D_over_B_v_D);
\draw (D_over_B_v_D) to node[midway, below right] {\small{$m$}} (Cm_over_B_v_D);

\node[dot] (C_over_C_v_D) at (5.6, 1.5) [label=below left:{\small{$C$}}] {};
\node[dot] (D_over_C_v_D) at (6.4, 1.5) [label=below right:{\small{$D$}}] {};
\node[dot] (Af_over_C_v_D) at (5.4, 2.1) [label=above:{\small{$A$}}] {};
\node[dot] (Bf_over_C_v_D) at (6.6, 2.1) [label=above:{\small{$B$}}] {};
\node (C_v_D) at (6, 0) {$C \join/ D$};
\draw (C_v_D) to (6, 0.75);
\draw (C_over_C_v_D) to node[midway, below] {\small{$m$}} (D_over_C_v_D);
\draw (C_over_C_v_D) to node[midway, left] {\small{$f$}} (Af_over_C_v_D);
\draw (D_over_C_v_D) to node[midway, right] {\small{$f$}} (Bf_over_C_v_D);

\end{diagram}

Having merged the graphs from joins of two regions, we must next merge the graphs of joins from three regions. For instance, take $B \join/ C \join/ D$. We can merge the graphs of $B \join/ C$ trivially (because they share no edges), we can merge the graphs of $C \join/ D$ along their shared $f$-edge, and we can merge the graphs of $B \join/ D$ along their shared $f$-edge. That yields:

\begin{diagram}

\node[dot] (B_over_B_v_C_v_D) at (-0.5, 1.5) [label=below right:{\small{$B$}}] {};
\node[dot] (C_over_B_v_C_v_D) at (0.5, 1.5) [label=below:{\small{$C$}}] {};
\node[dot] (D_over_B_v_C_v_D) at (0, 2) [label=above:{\small{$D$}}] {};
\node[dot] (Af_from_B_over_B_v_C_v_D) at (-1.1, 2) [label=left:{\small{$A$}}] {};
\node[dot] (Am_from_B_over_B_v_C_v_D) at (-1.2, 1) [label=left:{\small{$A$}}] {};
\node[dot] (Af_from_C_over_B_v_C_v_D) at (1.1, 2) [label=right:{\small{$A$}}] {};
\node (B_v_C_v_D) at (0, 0) {$B \join/ C \join/ D$};
\draw (B_v_C_v_D) to (0, 0.75);
\draw (B_over_B_v_C_v_D) to node[midway, above left] {\small{$f$}} (D_over_B_v_C_v_D);
\draw (C_over_B_v_C_v_D) to node[midway, above right] {\small{$m$}} (D_over_B_v_C_v_D);
\draw 
  (C_over_B_v_C_v_D) 
  to 
  node[midway, below right] {\small{$f$}} 
  (Af_from_C_over_B_v_C_v_D);
\draw 
  (B_over_B_v_C_v_D) 
  to
  node[midway, below left] {\small{$f$}} 
  (Af_from_B_over_B_v_C_v_D);
\draw 
  (B_over_B_v_C_v_D) 
  to
  node[midway, below right] {\small{$m$}} 
  (Am_from_B_over_B_v_C_v_D);

\end{diagram}

\noindent
By merging the graphs of all joins of three regions in this fashion, we get:

\begin{itemize}

\item
  $F(A \join/ B \join/ C) =$
    $\left\{
      \begin{array}{l l}
        \openTuple/ 
          & \{ f(A, B), f(A, C), m(A, B) \}, \\
          & \{ f(B, A), m(B, A), f(B, D) \}, \\
	  & \{ f(C, A), m(C, D) \} \quad \closeTuple/
      \end{array}
    \right\}$

\item 
  $F(A \join/ B \join/ D) =$
    $\left\{
      \begin{array}{l l}
        \openTuple/ 
          & \{ f(A, B), f(A, C), m(A, B) \}, \\
          & \{ f(B, A), m(B, A), f(B, D) \}, \\
          & \{ f(D, B), m(D, C) \} \quad \closeTuple/
      \end{array}
    \right\}$

\item
  $F(A \join/ C \join/ D) =$
    $\left\{
      \begin{array}{l l}
        \openTuple/
          & \{ f(A, B), f(A, C), m(A, B) \}, \\
	  & \{ f(C, A), m(C, D) \}, \\
          & \{ f(D, B), m(D, C) \} \quad \closeTuple/
      \end{array}
    \right\}$

\item $F(B \join/ C \join/ D) =$
    $\left\{
      \begin{array}{l l}
        \openTuple/
          & \{ f(B, A), m(B, A), f(B, D) \}, \\
          & \{ f(C, A), m(C, D) \}, \\
          & \{ f(D, B), m(D, C) \} \quad \closeTuple/
      \end{array}
    \right\}$

\end{itemize}

\noindent
At the top-most join of the locale, if we merge the graphs of all four regions, we get:

\begin{itemize}

\item
  $F(A \join/ B \join/ C \join/ D) =$
    $\left\{
      \begin{array}{l l}
        \openTuple/ 
          & \{ f(A, B), f(A, C), m(A, B) \}, \\
          & \{ f(B, A), m(B, A), f(B, D) \}, \\
	  & \{ f(C, A), m(C, D) \}, \\
	  & \{ f(D, B), m(D, C) \} \quad \closeTuple/
      \end{array}
    \right\}$

\end{itemize}

\noindent
As a picture:

\begin{diagram}

\node[dot] (B_over_A_v_B_v_C_v_D) at (-0.5, 1.5) [label=left:{\small{$B$}}] {};
\node[dot] (C_over_A_v_B_v_C_v_D) at (0.5, 1.5) [label=right:{\small{$C$}}] {};
\node[dot] (D_over_A_v_B_v_C_v_D) at (0, 2) [label=above:{\small{$D$}}] {};
\node[dot] (A_over_A_v_B_v_C_v_D) at (0, 1) [label=below:{\small{$A$}}] {};
\node (A_v_B_v_C_v_D) at (0, -0.5) {$A \join/ B \join/ C \join/ D$};
\draw (A_v_B_v_C_v_D) to (0, 0.25);
\draw 
  (B_over_A_v_B_v_C_v_D) 
  to 
  node[midway, above left] {\small{$f$}} 
  (D_over_A_v_B_v_C_v_D);
\draw 
  (C_over_A_v_B_v_C_v_D) 
  to 
  node[midway, above right] {\small{$m$}} 
  (D_over_A_v_B_v_C_v_D);
\draw 
  (C_over_A_v_B_v_C_v_D) 
  to 
  node[midway, below right] {\small{$f$}} 
  (A_over_A_v_B_v_C_v_D);
\draw 
  (B_over_A_v_B_v_C_v_D) 
  to[out=280, in=170] 
  node[midway, below left] {\small{$f$}} 
  (A_over_A_v_B_v_C_v_D);
\draw 
  (B_over_A_v_B_v_C_v_D) 
  to[out=340, in=110] 
  node[midway, above right] {\small{$m$}} 
  (A_over_A_v_B_v_C_v_D);

\end{diagram}

\noindent
In effect, the fiber over each region $U$ is a consistent assignment of relationships involving exactly the people in $U$, obtained by restriction from the full society. A restriction from $F(U)$ to $F(V)$ in effect forget any edges and vertices not involving people in $V$. It truly restricts the relationships mesh from those people in $U$ to only those in $V$.

This is in fact a sheaf. The sheaf condition requires that the relationship meshes over two opens agrees precisely on their overlap: when you restrict the meshes down to their overlap, you get the same sub-mesh. 

The result is a sheaf: a fused mesh of relationships over the population, which is glued together from smaller meshes over smaller subsets of the population. 

\begin{itemize}

\item Each fiber is a part of the whole (human society), and its data encodes the internal (relational) structure of that part.

\item Mereological overlap is then modeled by shared relationships: two parts overlap if their relational graphs intersect coherently.

\item Regions that are not covered by a mesh (as in $F(A \join/ D) = \EmptySet/$ and $F(B \join/ C) = \EmptySet/$) reflect mereological separation: the regions in question are simple not related, so there is nothing to glue.

\end{itemize}

\end{Example}

For another example, consider processes. A process (or more generally any sequence of events, states, etc.) can be seen as a part-whole complex too. 


% ----------------------------------------
\begin{Example}
\label{ex:simple-processes}

Imagine a scenario where something can do one of two things repeatedly: at each step, it can do one thing (``option $a$'') or another thing (``option $b$''), and then repeat the choice again.

To model this, fix a finite alphabet $\Sigma = \{ a, b \}$, with ``$a$'' for ``option $a$'' and ``$b$'' for ``option $b$.'' Then let $\Sigma^{\ast}$ be the set of all finite sequences (words) over $\Sigma$, with $\epsilon$ denoting the empty sequence. For instance, the sequence $aab$ represents the sequence of length 3 that picks ``option $a$'' first, then ``option $a$'' again, and then finally ``option $b$.''

Let us say that $\Sigma^{\leqslant n}$ is the set of all finite sequences less than length $n$, and let us say that $\Sigma^{=n}$ is the set of finite sequences of exactly length $n$. Hence:

\begin{itemize}

\item $\Sigma^{=0} = \{ \epsilon \}$.
\item $\Sigma^{=1} = \Sigma^{\leqslant 1} = \{ \epsilon, a, b \}$.
\item $\Sigma^{\leqslant 2} = \{ \epsilon, a, b, aa, bb, ab, ba \}$.
\item $\Sigma^{=2} = \{ aa, bb, ab, ba \}$.
\item Etc.

\end{itemize}

\noindent
Given sequences $w, v \in \Sigma^{\leqslant n}$ with $length(w) \leqslant length(v)$, let us write $w \subseteq v$ to denote that $w$ is a prefix of $v$, as in $aab \subseteq aabc$.

Next, define a topology over $\Sigma^{\leqslant n}$ by setting the open sets to be sequences that share a prefix:

\begin{itemize}

\item $U_{w} = \{ v \in \Sigma^{\leqslant n} \mid w \subseteq v \}$.

\end{itemize}

\noindent
So $U_{w}$ consists of all sequences that continue $w$. For instance, if $w = aab$, then we might picture $U_{w}$ as a kind of bouquet or bundle of sequences that are all bound at their shared stem ($aab$) but then branch out in different directions:

\begin{diagram}

\node at (0.1, -0.75) {$U_{aab}$};
\draw (-0.4, -0.4) rectangle (0.6, -1.15);

\node (1) at (0, 0) {$a$};
\node (2) at (0, 0.5) {$a$};
\node (3) at (0, 1) {$b$};
\draw (1) to (2) to (3);

\node (4) at (-0.35, 1.65) {$a$};
\node (5) at (-0.75, 2.25) {$b$};
\node (6) at (-1.5, 2.75) {};
\draw (3) to (4) to (5) to (6);

\node (7) at (0, 1.5) {$b$};
\node (8) at (0, 2) {$a$};
\node (9) at (-0.1, 2.5) {$a$};
\node (10) at (-0.25, 3) {$b$};
\node (11) at (-0.35, 3.5) {};
\draw (3) to (7) to (8) to (9) to (10) to (11);

\node (12) at (0.2, 1.65) {$a$};
\node (13) at (0.4, 2.25) {$a$};
\node (14) at (0.75, 3) {};
\draw (3) to (12) to (13) to (14);

\node (15) at (0.5, 1.5) {$b$};
\node (16) at (1, 1.75) {$b$};
\node (17) at (1.5, 2) {};
\draw (3) to (15) to (16) to (17);

\draw (0.25, 0) -- (0.5, 0) -- (0.5, 1) -- (0.25, 1);
\draw (0.5, 0.5) -- (1.25, 0.5);
\node at (2.5, 0.5) {\small{shared prefix $aab$}};

\end{diagram}

\noindent
We can form a locale from this topology. Let $\category{L}$ be the locale given by the presentation $\tuple{G, R}$, where:

\begin{itemize}

\item $G = \{ U_{w} \mid w \in \Sigma^{n} \}$, i.e., each open is a generator.
\item $R = \{ U_{w} \childOf/ U_{v} \mid v \subseteq w \}$, i.e., bouquets with longer prefixes are lower.

\end{itemize}

\noindent
For example, given $\Sigma^{\leqslant 2}$, we have the following generators:

\begin{itemize}

\item $G = \{ U_{\epsilon}, U_{a}, U_{b}, U_{aa}, U_{bb}, U_{ab}, U_{ba} \}$.

\end{itemize}

\noindent
Here are some of the relations:

\begin{itemize}

\item $U_{aa} \childOf/ U_{a}$ and $U_{ab} \childOf/ U_{a}$, since ``$a$'' is a prefix of $aa$ and $ab$.
\item $U_{bb} \childOf/ U_{b}$ and $U_{ba} \childOf/ U_{b}$, since ``$b$'' is a prefix of $bb$ and $ba$.
\item Every generator is lower than $U_{\epsilon}$, since $\epsilon$ (the empty sequence) is a prefix of every sequence.

\end{itemize}

\noindent
The Hasse diagram looks like this:

\begin{diagram}

\node (e) at (0, 3) {$U_{\epsilon}$};

\node (a) at (-1.5, 2) {$U_{a}$};
\node (b) at (1.5, 2) {$U_{b}$};

\node (aa) at (-3, 1) {$U_{aa}$};
\node (ab) at (-1, 1) {$U_{ab}$};
\node (ba) at (1, 1) {$U_{ba}$};
\node (bb) at (3, 1) {$U_{bb}$};

\node (bottom) at (0, -0.5) {$\bottom/$};

\draw (bottom) to (aa);
\draw (bottom) to (ab);
\draw (bottom) to (ba);
\draw (bottom) to (bb);

\draw (aa) to (a);
\draw (ab) to (a);
\draw (ba) to (b);
\draw (bb) to (b);

\draw (a) to (e);
\draw (b) to (e);

\end{diagram}

Think of moving upwards in this locale as forgetting information about (or alternatively, as committing less to) the history of the sequence. For example, think of $U_{ab}$ as a region where we know that ``$a$'' happened first and then ``$b$'' happened, but think of $U_{a}$ as a region where we know only that ``$a$'' happened first and we don't know what happened after that. The top element is $U_{\epsilon}$, which means we don't know anything about the sequence of actions. The $\bottom/$ element indicates not that we know nothing, but that there is no sequence at all.

Notice that implication moves upwards: $U_{ab}$ implies $U_{a}$ because if I know (at $U_{ab}$) that ``$a$'' happened first and then ``$b$'' happened, then I certainly know that ``$a$'' happened first. 

This particular locale is interesting because it models the ``process space'' of any 2-stage sequence that can make one of two choices at each stage. Let us now assign some actual processes to this ambient space, using a presheaf.

Imagine a machine $m$ that can run multiple concurrent processes, all of whom share the same memory. For simplicity, let us suppose that the machine has two registers ($R = \{ r_{1}, r_{2} \}$), each of which can hold one bit ($1$ or $0$). So, at any point in time the machine's memory state $S : \{ 0, 1 \} \times \{ 0, 1 \}$ can be one of the following:

\begin{itemize}

\item $S = \{ \tuple{0, 0}, \tuple{1, 0}, \tuple{0, 1}, \tuple{1, 1} \}$, with initial state $s_{0} = \tuple{0, 0}$.

\end{itemize}

We can think of the concurrent processes of interest as a selection of programs that we want to run on the machine all at the same time. In terms of behavior, let us say that each program-run reads a word from its input stream, one character at a time, and in response to each character, it takes one of the following actions $A$: it writes a value ($1$ or $0$) to one of the registers, it writes (possibly distinct) values to both registers, or it does nothing and leaves the registers as they are:

\begin{itemize}

\item $A = \{ \{ r1 \mapsto v \}, \{ r2 \mapsto v \}, \{ r1 \mapsto v, r2 \mapsto w \}, \EmptySet/ \}$, where $v, w \in \{ 0, 1 \}$.

\end{itemize}

We can define a process (program trace) as a map from $n$-length words to $n$-length sequences of write actions, where we require that such maps agree on prefixes (since a process responding to $ab$ and $aa$ would do the same thing on the first $a$). This way, a program trace records for each input stream the sequence of write actions that result. For concreteness, here are two such traces:

\begin{itemize}

\item $f : \Sigma^{=2} \to A \times A$

  \begin{itemize}
    \item $f(aa) = \tuple{\{ r1 \mapsto 1 \}, \{ r1 \mapsto 0 \} \}}$
    \item $f(ab) = \tuple{\{ r1 \mapsto 1 \}, \{ r2 \mapsto 0 \} \}}$
    \item $f(bb) = \tuple{\{ \{ r1 \mapsto 0 \}, \{ r2 \mapsto 1 \} \}}$
    \item $f(ba) = \tuple{\{ \{ r1 \mapsto 0 \}, \{ r1 \mapsto 1 \} \}}$
  \end{itemize}

\item $g : \Sigma^{=2} \to A \times A$

  \begin{itemize}
    \item $g(aa) = \tuple{\{ r2 \mapsto 0 \}, \{ r2 \mapsto 0 \} \}}$
    \item $g(ab) = \tuple{\{ r2 \mapsto 0 \}, \EmptySet/ \}}$
    \item $g(bb) = \tuple{\{ \{ r1 \mapsto 1 \}, \EmptySet/ \}}$
    \item $g(ba) = \tuple{\{ \{ r1 \mapsto 1 \}, \EmptySet/ \}}$
  \end{itemize}

\end{itemize}

\noindent
Let us say that we now want to run $f$ and $g$ concurrently on the machine. For each word $w \in \Sigma^{=2}$, let us write $\jointRun{w}$ for 

\[ 
  (f(w), g(w)), 
\]

\noindent
i.e., the joint run of $f$ and $g$ on $w$. For instance:

\[
  \jointRun{aa} = (f(aa), g(aa)) = (\tuple{\{ r1 \mapsto 1 \}, \{ r1 \mapsto 0 \} \}}, \tuple{\{ r2 \mapsto 0 \}, \{ r2 \mapsto 0 \} \}}).
\]

Next, let us say that two joint runs $\jointRun{w}$ and $\jointRun{v}$ are prefix-compatible iff:

\begin{itemize}
  \item 
    For every stage $k$ such that $w$ and $v$ share their first $k$ letters,
    the combined writes of $f$ and $g$ at stage $k$ 
    do not assign different values to the same register.
\end{itemize}

\noindent
For instance, $\jointRun{aa}$ and $\jointRun{ab}$ are prefix-compatible because at stage 1 (at letter $a$), their writes do not conflict: 

\begin{itemize}
  \item $f(aa)$ and $f(ab)$ write $1$ to $r1$, while $g(aa)$ and $g(ab)$ write $0$ to $r2$, and this is no conflict because they write to different registers.
\end{itemize}

By contrast, $\jointRun{bb}$ and $\jointRun{ba}$ are not prefix-compatible because at stage 1 (at letter $b$) their writes do conflict:

\begin{itemize}
  \item $f(bb)$ and $f(ba)$ write $0$ to $r1$, while $g(bb)$ and $g(ba)$ write $1$ to $r1$, so they attempt to write conflicting values to the same register.
\end{itemize}

For a region $U_{w}$ with $|w| \leq 2$, let $\extensions/(U_{w})$ be the set of length-$2$ words that extend $w$. For instance, $\extensions/(U_{a}) = \{ aa, ab \}$, since $aa$ and $ab$ extend $a$, and $\extensions/(U_{ab}) = \{ ab \}$, since $ab$ is already a fully extended length-$2$ word.

Now let us define a presheaf $F$ as follows. For each region $U_{w}$, let us provide an execution model that describes how $f$ and $g$ execute $w$ and then continue on. More specifically, we need to assign prefix-compatible program runs for the extensions of $w$. The idea is that $F(U_{w})$ will present a coherent description of how the machine will behave, as $f$ and $g$ jointly execute $w$ and then continue on to their continuations. 

At the most specified regions ($aa$, $ab$, $bb$, and $ba$), everything is fully specified, so the joint runs are fully determined already:

\begin{itemize}
  \item $F(U_{aa}) = \{ aa \mapsto \jointRun{aa} \}$
  \item $F(U_{ab}) = \{ ab \mapsto \jointRun{ab} \}$
  \item $F(U_{bb}) = \{ bb \mapsto \jointRun{bb} \}$
  \item $F(U_{ba}) = \{ ba \mapsto \jointRun{ba} \}$
\end{itemize}

\noindent
The more complicated case involves a less specified region, e.g. $U_{a}$. At this region, we know that the first step $a$ happened, but we don't yet know whether the second step will be $a$ or $b$. So, from the point of view of $U_{a}$, both continuations are possible. 

Thus, what we need for $F(U_{a})$ is a coherent description of how the machine will behave no matter which continuation actually occurs next. We must therefore:

\begin{itemize}

\item Pick a joint run of $aa$.
\item Pick a joint run of $ab$.
\item But these two choices must be prefix-compatible, since they are supposed to represent the same joint run that has two different futures.

\end{itemize}

\noindent
Are there any joint runs of $f$ and $g$ on $aa$ and $ab$ that are prefix-compatible at $a$? Yes:

\begin{itemize}
  \item $aa \mapsto \jointRun{aa}$
  \item $ab \mapsto \jointRun{ab}$
\end{itemize}

\noindent
For as we saw earlier, $\jointRun{aa}$ and $\jointRun{ab}$ are prefix-compatible. Hence, there is a coherent execution model for $f$ and $g$ at $U_{a}$:

\begin{itemize}
  \item $F(U_{a}) = \{ aa \mapsto \jointRun{aa}, ab \mapsto \jointRun{ab} \}$
\end{itemize}

\noindent
Now consider $U_{b}$. The continuations of $b$ are $bb$ and $ba$. Are there any joint runs of $f$ and $g$ on $bb$ and $ba$ that are prefix-compatible? Here, the answer is no, for as we saw above, $\jointRun{bb}$ and $\jointRun{ba}$ are not prefix-compatible. Hence, there is no execution model for $f$ and $g$ at $U_{b}$:

\begin{itemize}
  \item $F(U_{b}) = \EmptySet/$
\end{itemize}

\noindent
What about $U_{\epsilon}$? This would have to be an execution model of a joint run that is prefix compatible with the execution models at both $U_{a}$ and $U_{b}$. Since there is no possible execution model at $U_{b}$, no execution model is possible for $U_{\epsilon}$:

\begin{itemize}
  \item $F(U_{\epsilon}) = \EmptySet/$
\end{itemize}

\noindent
Formally, we can summarize the above description of $F$ as follows. Let $\jointRunSymbol/ = \{ \jointRun{v} \mid v \in \Sigma^{=2} \}$. Then:

\[
F(U_w)
=
\left\{
  s : \extensions/(w) \to \jointRunSymbol/
  \mid
  \begin{array}{l}
    \text{(i) } s(v) = \jointRun{v} \text{ for all } v \in \extensions/(w), \\[4pt]
    \text{(ii) } \{ s(v) \mid v \in \extensions/(w) \}
    \text{ is pairwise prefix-compatible}
  \end{array}
\right\}
\]

\noindent
For the bottom fiber, where no processes occur, assign the special symbol zero:

\begin{itemize}

  \item $F(\bottom/) = \{ 0 \}$.

\end{itemize}

To notate the restriction of a function $f : B \to D$ to a smaller domain $C \subseteq B$, write $f\funcRestrict/_{C}$. Then, whenever $U_{v} \childOf/ U_{w}$, the restriction maps are straightforward restrictions:
\[
  \restrict{U_{w}}{U_{v}}(s) = s\funcRestrict/_{\extensions/(U_v)}.
\]

\noindent
Hence, for example:

\begin{itemize}

\item 
  $\restrict{U_{a}}{U_{ab}}(\{ aa \mapsto \jointRun{aa}, ab \mapsto \jointRun{ab} \}) =
    \{ ab \mapsto \jointRun{ab} \}$.

\item 
  $\restrict{U_{a}}{U_{aa}}(\{ aa \mapsto \jointRun{aa}, ab \mapsto \jointRun{ab} \}) =
    \{ aa \mapsto \jointRun{aa} \}$.

\end{itemize}

The maximal fusions in this presheaf occur over $U_{a}$: the execution model in $U_{a}$'s fiber is glued from those of $U_{aa}$ and $U_{ab}$, exactly as one would expect, since $f$ and $g$ can run concurrently without conflict at $a$. By contrast, there is no gluing over $U_{b}$, since $f$ and $g$ cannot run concurrently without conflict at $b$. 

This is not a sheaf, because it is missing gluings (e.g., over $U_{b}$). However, it is a monopresheaf, because when gluings exist (over $U_{a}$), they are unique.

This relevance of this example is t hat it illustrates how sheaf theory can model processes, concurrency, and resource conflicts. Here the processes are programs running on a simple machine, but they could just as easily be biological processes competing for resources, etc.

Whatever the concrete details may be, this example captures how local behaviors integrate and extend  over larger regions of the process space. One might naively think that the ``parts'' of such systems are the processes. But there is a different way to slice it: if you want to talk about the integrity of the ``whole'' of a concurrent system, you need to talk about how that involves coherent, integrated behavior that is functionally united locally across the various ``regions'' and ``stages'' of the system's evolution.

\end{Example}

Sheaf theory works in continuous environments too.

% ----------------------------------------
\begin{Example}

Suppose we want to model the inhabitants of an apartment building over time. Let $T = (0, 10) \subseteq \Reals/$ be an open interval representing a period of time (a span of 10 years, say). 

Let $T$ have the standard Euclidean topology, and let $\category{L}$ be the locale of opens of the topology. This is the ambient locale we want to work with.

Next, let $P$ be the set of people who at some point or other lived in the building:

\[
  P = \{ A, B, C, \ldots \}, \text{ with $A$ short for Alice, $B$ for Bob, $C$ for Carol, and so on. }
\]

Let $I$ assign to each person the set of intervals during which they lived in the building. For instance:

\begin{itemize}
  \item $I(A) = \{ (1, 3), (4, 7) \}$
  \item $I(B) = \{ (4, 9) \}$
  \item $I(C) = \{ (6, 10) \}$
\end{itemize}

Let $F$ be a presheaf given as follows. For each time span $U \in \category{L}$:

\[
  F(U) = \{ p \in P \mid U \subseteq V, \text{ for some } V \in I(p) \}
\]

In other words, $F(U)$ is the set of people who live in the building for the entire duration of $U$.

For $V \childOf/ U$, the restriction maps are just inclusion:

\[
  \restrict{U}{V}(J) = J,
\]

\noindent
since if the set of people $J$ lived in the building throughout the span $U$, then they most certainly lived there during the smaller interval $V$.

This is a sheaf, since any compatible selection of patch candidates glues uniquely. For any cover $\{ U_{i} \}_{i \in I}$ of $U$:

\[
  F(U) = \bigcap_{i} F(U_{i}).
\]

A fusion in this sheaf is a glued section, and its parts are the patch candidates it is glued from. For example, take $U = (6, 7)$, with cover $\{ U_{1} = (6, 6.5), U_{2} = (6.4, 7) \}$. Any selection of compatible patch candidates from this cover glue uniquely.

This is a particularly simple sheaf, but the sheaf's strong gluing conditions tell us why the parts glue together so straightforwardly here. Gluing is thoroughly integrated throughout the structure. 

\end{Example}


% ----------------------------------------
\begin{Example}

For another continuous example, let's model a lump of clay through time.

Let $T = (0, 10)$ be a span of time, and let $\category{L}$ be the locale of the opens of $T$ with its standard Euclidean topology again.

For simplicity, let us assume that 3-dimensional space is just $\Reals/^{3}$. Then fix a function

\[
  \phi : T \to \powerset/(\Reals/^{3})
\]

\noindent
that, for each $t \in T$,

\[
  \phi(t) \subseteq \Reals/^{3}
\]

\noindent
is the open region of space occupied by the clay at time $t$. 

If we think of $\phi(t)$ as a snapshot of the clay at $t$, then at some $t$s, $\phi(t)$ might be shaped like a statue, at other times like a lump, at still other times like two disconnected lumps, and so on.

With that background fixed, let us now define a presheaf $F$ that assigns material parts to each interval of $T$. In particular, for each interval $U \in \category{L}$:

\[
  F(U) = \{ S \subseteq \Reals/^{3} \mid S \text{ is open and } \forall t \in U, S \subseteq \phi(t) \}.
\]

\noindent
In other words, F(U) is the set of the clay's material parts that persist through the duration of $U$. 

Restriction is inclusion again, since persistence through a larger time span $U$ implies persistence through a smaller span $V \childOf/ U$:

\[
  \restrict{U}{V}(S) = S.
\]

This is a sheaf, since compatible local section glue by intersection. The fibers of this sheaf are typically infinite: each fiber includes the whole lump of clay, all of is sub-regions, and these regions are themselves spatially continuous.

Given a time span $U$, if 

\[
  \bigcap_{t \in U} \phi(t)
\]

\noindent
is connected, then there will be a maximal connected section $S \in F(U)$ such that all other sections in $F(U)$ sit inside it. This models a single lump of clay through time.

By contrast, if

\[
  \bigcap_{t \in U} \phi(t)
\]

\noindent
has two or more connected components, then there will not be a maximal connected section $S \in F(U)$ that all other sections of $F(U)$ fit inside. This models a fragmented lump of clay through time.
 
 What exactly does the sheaf give us here that $\phi$ doesn't? What $\phi$ gives us is a time-indexed history of spatial occupation. It is like a movie: each frame is just a picture. It says nothing about what the material parts are, or which parts persist through time. That information has to be imposed on top of $\phi$. 
 
 $F$ does exactly that, and makes it explicit. $F$ assigns to the locale precisely what the material parts are that persist through time, along with a principled notion of fusion. In short, $\phi$ gives us what points in space are occupied at each instant, whereas $F$ gives us which parts persist over regions of time, and how they compose.
 
Examples like this can be enriched to model further features. For instance, we might allow multiple overlapping material parts in the same fiber, each tagged by a different modifier of some kind.

With the lump of clay, each fiber only carried persistent material parts. But we might let the fibers carry persistent material parts tagged with an accidental mode (e.g., a posture, like seated or standing). 

Let $\e{Posture} = \{ seated, standing, \ldots, \} \cup \{ unspecified \}$. Then for every $U \in \category{L}$, we can say that $F(U)$ is a set of pairs $\tuple{S, \pi}$ such that $\forall t \in U$, $S \subseteq \phi(t)$, and $\pi \in \e{Posture}$. Intuitively, these pairs are the material parts in standing-Socrates, seated-Socrates, and Socrates-simpliciter that persist in the given mode throughout $U$. This presheaf can have multiple, distinct persistent material fusions (e.g., Socrates-simpliciter and seated-Socrates) that simultaneously inhabit the same regions of space and differ only by their accidental mode.

\end{Example}



% ----------------------------------------
TODO:
\begin{itemize}

\item Note Spivak et al's behavioral mereology is an example of a \Gsheaf/ (and check the details to make sure that's really true).

\item Mormann's ``structural mereology'' is basically just our thesis. Add examples from his similarity structures.
  
\end{itemize}
